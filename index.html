<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>MusicCore</title>
    <script src="https://cdn.jsdelivr.net/npm/tone@14.7.77/build/Tone.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/midibuilder@1.1.0/lib/midibuilder.min.js"></script>
    <style>
        body {
            margin: 0;
            font-family: sans-serif;
            overflow: hidden;
            display: flex;
            flex-direction: column;
            height: 100vh;
            background: #282828;
            color: #ccc;
        }

        #menubar {
            background: #444;
            color: white;
            padding: 5px 10px;
            font-size: 14px;
            display: flex;
            gap: 15px;
            border-bottom: 1px solid #000;
        }

        .dropdown {
            position: relative;
            display: inline-block;
        }

        .dropdown-content {
            display: none;
            position: absolute;
            background-color: #f9f9f9;
            min-width: 120px;
            box-shadow: 0px 8px 16px 0px rgba(0,0,0,0.2);
            z-index: 100;
        }

        .dropdown:hover .dropdown-content {
            display: block;
        }

        .dropdown-content a {
            color: black;
            padding: 8px 12px;
            text-decoration: none;
            display: block;
            cursor: pointer;
        }

        .dropdown-content a:hover,
        .dropdown-content a.active {
            background-color: #f1f1f1;
        }
        
        .dropdown-content a.active {
            background-color: #4CAF50;
            color: white;
        }

        .divider {
            height: 1px;
            background: #ccc;
            margin: 5px 0;
        }
        
        #controls {
            padding: 10px;
            background: #333;
            color: white;
            display: flex;
            align-items: center;
            gap: 10px;
            border-bottom: 1px solid #000;
        }

        #controls button {
            padding: 5px 15px;
            font-size: 16px;
            cursor: pointer;
            border: none;
            background: #555;
            color: #eee;
        }
        
        #controls button:hover,
        #controls button.active {
            background: #777;
        }
        
        #bpmControl {
            margin-left: auto;
            display: flex;
            align-items: center;
            gap: 10px;
        }

        #bpmDisplay {
            font-size: 16px;
            padding: 5px;
            background: #555;
            border-radius: 4px;
            min-width: 60px;
            text-align: center;
        }

        #bpmSlider {
            -webkit-appearance: none;
            width: 150px;
            height: 8px;
            background: #5895f3;
            outline: none;
            opacity: 0.7;
            transition: opacity .2s;
            border-radius: 4px;
        }
        
        #bpmSlider::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 20px;
            height: 20px;
            background: #ff9800;
            cursor: pointer;
            border-radius: 50%;
        }

        #tool-buttons {
            display: flex;
            gap: 10px;
        }

        #tool-buttons button {
            width: 40px;
            height: 40px;
            background: #555;
            border: 1px solid #666;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        #tool-buttons button.active {
            background: #5895f3;
            border-color: #5895f3;
        }
        
        #tool-buttons button:hover {
            background: #777;
        }

        .tool-icon {
            width: 32px;
            height: 32px;
        }
        
        #tracks {
            display: flex;
            flex-direction: column;
            width: 150px;
            min-width: 100px;
            max-width: 300px;
            background: #333;
            padding: 10px;
            border-right: 1px solid #000;
            overflow-y: auto;
            flex-shrink: 0;
            resize: horizontal;
        }

        .track-button {
            position: relative;
            display: flex;
            align-items: center;
            padding: 8px;
            margin-bottom: 5px;
            border: 1px solid #555;
            background: #444;
            color: white;
            cursor: pointer;
        }

        .track-button.active {
            background: #5895f3;
            border-color: #5895f3;
        }
        
        .track-name {
            flex-grow: 1;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }

        .track-name-input {
            width: 100%;
            background: #555;
            color: #eee;
            border: 1px solid #777;
            padding: 0 4px;
            box-sizing: border-box;
        }
        
        .delete-track-btn {
            background: #f44336;
            color: white;
            border: none;
            border-radius: 50%;
            width: 20px;
            height: 20px;
            font-size: 14px;
            line-height: 1;
            cursor: pointer;
            margin-left: 5px;
            padding: 0;
            display: flex;
            align-items: center;
            justify-content: center;
            opacity: 0.8;
        }
        
        .delete-track-btn:hover {
            opacity: 1;
        }
        
        .delete-track-btn.disabled {
            background: #777;
            cursor: not-allowed;
        }

        #addTrack {
            margin-top: 10px;
            background: #5895f3;
        }

        #main-content {
            display: flex;
            flex: 1;
        }

        #track-resizer {
            width: 5px;
            cursor: ew-resize;
            background: #555;
        }

        #pianoroll-container {
            display: flex;
            flex: 1;
            width: 100vw;
            background: #383838;
        }

        #keys {
            width: 80px;
            background: #222;
            color: white;
            overflow-y: scroll;
            flex-shrink: 0;
            border-right: 1px solid #000;
        }
        
        #keys::-webkit-scrollbar {
            width: 0px;
            background: transparent;
        }

        .key {
            height: 20px;
            border-bottom: 2px solid #555;
            text-align: center;
            font-size: 10px;
            line-height: 20px;
            user-select: none;
        }

        .white {
            background: #fff;
            color: black;
        }

        .black {
            background: #555;
            color: white;
        }

        #grid-wrapper {
            flex: 1;
            position: relative;
            overflow: scroll;
        }

        #grid {
            position: absolute;
            top: 0;
            left: 0;
            background: #484848;
            height: 100%;
            width: max-content;
        }

        .grid-row {
            position: relative;
            height: 20px;
            border-bottom: 2px solid #555;
        }

        .grid-cell {
            position: absolute;
            top: 0;
            bottom: 0;
            width: 40px;
            border-right: 2px solid #666;
        }

        .beat {
            border-right: 3px solid #888;
        }

        .bar {
            border-right: 4px solid #5895f3;
        }

        .note {
            position: absolute;
            height: 18px;
            border: 1px solid #333;
            border-radius: 3px;
            cursor: move;
            z-index: 10;
        }
        
        .note.active {
            background: #ff9800 !important;
        }
        
        .note-handle {
            position: absolute;
            right: 0;
            top: 0;
            bottom: 0;
            width: 8px;
            cursor: ew-resize;
            background: rgba(0,0,0,0.1);
        }

        #playhead {
            position: absolute;
            top: 0;
            bottom: 0;
            width: 2px;
            background: #ff5555;
            z-index: 20;
            cursor: grab;
        }
        
        #noteEditorModal {
            display: none;
            position: absolute;
            z-index: 101;
            background: #333;
            border: 1px solid #555;
            border-radius: 5px;
            padding: 15px;
            box-shadow: 0 4px 8px rgba(0,0,0,0.5);
            color: #eee;
        }
        
        .modal-content {
            display: flex;
            flex-direction: column;
            gap: 10px;
        }
        
        .modal-content div {
            display: flex;
            align-items: center;
            gap: 10px;
        }
        
        .modal-content input {
            width: 80px;
            background: #444;
            border: 1px solid #666;
            color: #eee;
            padding: 5px;
            border-radius: 3px;
        }
        
        #modalButtons {
            display: flex;
            justify-content: flex-end;
            gap: 10px;
            margin-top: 10px;
        }
        
        #modalButtons button {
            padding: 5px 10px;
            border: none;
            cursor: pointer;
            border-radius: 3px;
        }
        
        #modalButtons button.apply {
            background: #5895f3;
            color: white;
        }
        
        #modalButtons button.delete {
            background: #f44336;
            color: white;
        }
    </style>
</head>
<body>

    <div id="menubar">
        <div class="dropdown">
            <span class="dropbtn">ファイル</span>
            <div class="dropdown-content">
                <a href="#" id="loadProject">プロジェクト読み込み (.mcp)</a>
                <a href="#" id="saveProject">プロジェクト書き出し (.mcp)</a>
                <a href="#" id="importMidi">MIDI読み込み (.mid)</a>
                <a href="#" id="exportMidi">MIDI書き出し (.mid)</a>
            </div>
        </div>
        <div id="tool-buttons">
            <button id="pencilTool" data-tool="pencil" class="active"><img src="pencil.png" class="tool-icon"></button>
            <button id="eraserTool" data-tool="eraser"><img src="eraser.png" class="tool-icon"></button>
        </div>
        <div class="dropdown">
            <span class="dropbtn">設定</span>
            <div class="dropdown-content">
                <a href="#" class="grid-setting active" data-grid="4">グリッド: 1/4</a>
                <a href="#" class="grid-setting" data-grid="8">グリッド: 1/8</a>
                <a href="#" class="grid-setting" data-grid="16">グリッド: 1/16</a>
                <div class="divider"></div>
                <a href="#" id="setTempo">拍子設定</a>
                <a href="#" id="setOctave">オクターブ設定</a>
                <div class="divider"></div>
                <a href="#" class="instrument-setting" data-instrument="synth">楽器: Synthesizer</a>
                <a href="#" class="instrument-setting active" data-instrument="piano">楽器: Piano (Sampler)</a>
                <a href="#" class="instrument-setting" data-instrument="releaseCutPiano">楽器: Release-Cut Piano</a>
            </div>
        </div>
    </div>

    <div id="controls">
        <button id="playToggleBtn">▶︎</button>
        <div id="bpmControl">
            <span id="bpmDisplay">BPM: 120</span>
            <input type="range" id="bpmSlider" min="40" max="240" value="120">
        </div>
    </div>
    
    <div id="main-content">
        <div id="tracks">
            <button id="addTrack">+ トラック追加</button>
        </div>
        <div id="track-resizer"></div>
        <div id="pianoroll-container">
            <div id="keys"></div>
            <div id="grid-wrapper">
                <div id="grid"></div>
                <div id="playhead"></div>
            </div>
        </div>
    </div>

    <div id="noteEditorModal">
        <div class="modal-content">
            <div>
                <span>開始位置:</span>
                <input type="number" id="modalStart" min="0" value="0">
            </div>
            <div>
                <span>長さ:</span>
                <input type="number" id="modalLength" min="1" value="1">
            </div>
            <div id="modalButtons">
                <button class="apply">適用</button>
                <button class="delete">削除</button>
            </div>
        </div>
    </div>

    <script>
        const NOTES = ["C", "C#", "D", "D#", "E", "F", "F#", "G", "G#", "A", "A#", "B"];
        const ROW_HEIGHT = 20;
        const NOTE_HEIGHT = 18;
        const COL_WIDTH = 40;
        const TRACK_COLORS = ['#5895f3', '#f39558', '#95f358', '#f35895', '#58f395'];
        
        let notesData = [];
        let allNotes = [];
        let currentTool = 'pencil';
        let currentGridDivision = 4;
        let currentOctaves = 2;
        let startOctave = 3;
        let currentBPM = 120;
        let beatsPerBar = 4;
        let noteValue = 4;
        let isPlayheadDragging = false;
        let wasPlayingBeforeDrag = false;
        let playheadEventId = null;

        let instruments = {};
        let parts = {};
        let tracksData = [];
        let isAudioContextInitialized = false;
        let activeNoteElement = null;
        let nextNoteId = 0;
        let nextTrackId = 0;
        let currentTrackId = 0;
        let isResizing = false;
        let currentInstrument = 'piano';
        
        const keysDiv = document.getElementById("keys");
        const gridWrapper = document.getElementById("grid-wrapper");
        const gridDiv = document.getElementById("grid");
        const playheadDiv = document.getElementById("playhead");
        const playToggleBtn = document.getElementById("playToggleBtn");
        const bpmDisplay = document.getElementById("bpmDisplay");
        const bpmSlider = document.getElementById("bpmSlider");
        const setTempoBtn = document.getElementById("setTempo");
        const setOctaveBtn = document.getElementById("setOctave");
        const saveBtn = document.getElementById("saveProject");
        const loadBtn = document.getElementById("loadProject");
        const exportMidiBtn = document.getElementById("exportMidi");
        const importMidiBtn = document.getElementById("importMidi");
        const toolButtonsDiv = document.getElementById("tool-buttons");
        const tracksDiv = document.getElementById("tracks");
        const addTrackBtn = document.getElementById("addTrack");
        const trackResizer = document.getElementById("track-resizer");
        
        const noteEditorModal = document.getElementById("noteEditorModal");
        const modalStartInput = document.getElementById("modalStart");
        const modalLengthInput = document.getElementById("modalLength");
        const modalApplyBtn = noteEditorModal.querySelector('.apply');
        const modalDeleteBtn = noteEditorModal.querySelector('.delete');
        
        // Initialization
        createTrack({ id: nextTrackId++, name: 'Track 1', instrument: currentInstrument });
        renderTracks();
        initializeUI();

        // ------------------ Tone.js and Playback Logic ------------------

        async function setupTone() {
            if (isAudioContextInitialized) return;

            try {
                await Tone.start();
                
                isAudioContextInitialized = true;
                console.log('Audio context initialized successfully.');
                tracksData.forEach(track => createInstrumentAndPart(track.id, track.instrument));
                updateAllParts();

            } catch (e) {
                alert('オーディオの初期化に失敗しました。ブラウザの設定を確認してください。\n詳細: ' + e.message);
                console.error(e);
                isAudioContextInitialized = false;
            }
        }
        
        function createInstrumentAndPart(trackId, instrumentType) {
            let instrument;
            const pianoSamples = {
                'C1': 'C1.mp3', 'D#1': 'Ds1.mp3', 'F#1': 'Fs1.mp3', 'A1': 'A1.mp3',
                'C2': 'C2.mp3', 'D#2': 'Ds2.mp3', 'F#2': 'Fs2.mp3', 'A2': 'A2.mp3',
                'C3': 'C3.mp3', 'D#3': 'Ds3.mp3', 'F#3': 'Fs3.mp3', 'A3': 'A3.mp3',
                'C4': 'C4.mp3', 'D#4': 'Ds4.mp3', 'F#4': 'Fs4.mp3', 'A4': 'A4.mp3',
                'C5': 'C5.mp3', 'D#5': 'Ds5.mp3', 'F#5': 'Fs5.mp3', 'A5': 'A5.mp3',
                'C6': 'C6.mp3', 'D#6': 'Ds6.mp3', 'F#6': 'Fs6.mp3', 'A6': 'A6.mp3',
                'C7': 'C7.mp3', 'D#7': 'Ds7.mp3', 'F#7': 'Fs7.mp3', 'A7': 'A7.mp3',
                'C8': 'C8.mp3',
            };
            
            if (instrumentType === 'synth') {
                instrument = new Tone.PolySynth(Tone.Synth).toDestination();
            } else if (instrumentType === 'piano') {
                 // より広い音域に対応するピアノ音源
                instrument = new Tone.Sampler({
                    urls: pianoSamples,
                    baseUrl: "https://tonejs.github.io/audio/salamander/",
                    release: 1, // 通常のリリース時間
                    onload: () => {
                        console.log(`Sampler for track ${trackId} loaded.`);
                    },
                    onerror: (e) => {
                        console.error(`Sampler for track ${trackId} failed to load:`, e);
                        alert("ピアノ音源の読み込みに失敗しました。ネットワーク接続を確認してください。");
                    }
                }).toDestination();
            } else if (instrumentType === 'releaseCutPiano') {
                 // リリース時間を短くしたピアノ音源
                instrument = new Tone.Sampler({
                    urls: pianoSamples,
                    baseUrl: "https://tonejs.github.io/audio/salamander/",
                    release: 0.05, // リリース時間を極端に短く設定
                    onload: () => {
                        console.log(`Release-Cut Sampler for track ${trackId} loaded.`);
                    },
                    onerror: (e) => {
                        console.error(`Release-Cut Sampler for track ${trackId} failed to load:`, e);
                        alert("リリースカットピアノ音源の読み込みに失敗しました。ネットワーク接続を確認してください。");
                    }
                }).toDestination();
            }

            const part = new Tone.Part((time, event) => {
                const note = event.note;
                const noteElement = document.querySelector(`.note[data-id="${note.id}"]`);
                const durationInTicks = (note.length / currentGridDivision) * Tone.Transport.ppq;
                const durationInSeconds = Tone.Transport.ticksToSeconds(durationInTicks);

                if (instrumentType === 'synth') {
                    instrument.triggerAttackRelease(note.note, durationInSeconds, time, 1);
                } else {
                    instrument.triggerAttack(note.note, time, 1);
                    Tone.Transport.scheduleOnce(() => {
                        instrument.triggerRelease(note.note, "+0.01");
                    }, time + durationInSeconds);
                }
                
                if (noteElement) {
                    noteElement.classList.add('active');
                    setTimeout(() => {
                        noteElement.classList.remove('active');
                    }, durationInSeconds * 1000);
                }
            }).start(0);
            part.loop = true;
            part.loopEnd = '4m';

            instruments[trackId] = instrument;
            parts[trackId] = part;
        }
        
        function updateAllParts() {
            if (!isAudioContextInitialized) return;

            for (const id in parts) {
                if (parts[id]) {
                    parts[id].clear();
                }
            }
            
            notesData.forEach(note => {
                const startInTicks = (note.start / currentGridDivision) * Tone.Transport.ppq;
                
                if (parts[note.trackId]) {
                    parts[note.trackId].add(Tone.Transport.ticksToSeconds(startInTicks), { note: note.note, id: note.id, length: note.length, trackId: note.trackId });
                }
            });
        }
        
        function startPlayback() {
            Tone.Transport.start();
            playToggleBtn.textContent = '||';
            if (!playheadEventId) {
                playheadEventId = Tone.Transport.scheduleRepeat((time) => {
                    const pixels = Tone.Transport.ticks * (COL_WIDTH / Tone.Transport.ppq);
                    playheadDiv.style.transform = `translateX(${pixels}px)`;
                    gridWrapper.scrollLeft = pixels - gridWrapper.clientWidth / 2;
                }, '16n');
            }
        }

        function pausePlayback() {
            Tone.Transport.pause();
            playToggleBtn.textContent = '▶︎';
            if (playheadEventId) {
                Tone.Transport.clear(playheadEventId);
                playheadEventId = null;
            }
        }
        
        function resetPlayback() {
            Tone.Transport.stop();
            Tone.Transport.seconds = 0;
            playToggleBtn.textContent = '▶︎';
            playheadDiv.style.transform = `translateX(0px)`;
            gridWrapper.scrollLeft = 0;
            document.querySelectorAll('.note').forEach(note => note.classList.remove('active'));
            if (playheadEventId) {
                Tone.Transport.clear(playheadEventId);
                playheadEventId = null;
            }
        }

        playToggleBtn.addEventListener("click", async () => {
            await setupTone();
            if (!isAudioContextInitialized) return;
            
            if (notesData.length === 0) {
                alert("再生するノートがありません。ノートを作成してください。");
                return;
            }

            if (Tone.Transport.state === "stopped" || Tone.Transport.state === "paused") {
                startPlayback();
            } else {
                pausePlayback();
            }
        });

        // ------------------ Track and UI Logic ------------------

        function createTrack(trackData) {
            tracksData.push(trackData);
            if (isAudioContextInitialized) {
                createInstrumentAndPart(trackData.id, trackData.instrument);
            }
        }
        
        function deleteTrack(trackId) {
            if (tracksData.length <= 1) {
                alert("最後のトラックは削除できません。");
                return;
            }
        
            const trackIndex = tracksData.findIndex(track => track.id === trackId);
            if (trackIndex !== -1) {
                tracksData.splice(trackIndex, 1);
            }
            
            notesData = notesData.filter(note => note.trackId !== trackId);

            if (parts[trackId]) {
                parts[trackId].dispose();
                delete parts[trackId];
            }
            if (instruments[trackId]) {
                instruments[trackId].dispose();
                delete instruments[trackId];
            }
            
            if (currentTrackId === trackId) {
                currentTrackId = tracksData.length > 0 ? tracksData[0].id : null;
            }
            
            renderTracks();
            drawKeysAndGrid();
            updateAllParts();
        }

        function renderTracks() {
            tracksDiv.querySelectorAll('.track-button').forEach(btn => btn.remove());

            tracksData.forEach((track, index) => {
                const newTrackBtn = document.createElement("button");
                newTrackBtn.className = "track-button";
                newTrackBtn.dataset.trackId = track.id;
                
                const trackNameSpan = document.createElement("span");
                trackNameSpan.className = "track-name";
                trackNameSpan.textContent = track.name;
                newTrackBtn.appendChild(trackNameSpan);
                
                const deleteBtn = document.createElement("button");
                deleteBtn.textContent = '×';
                deleteBtn.className = 'delete-track-btn';
                if (tracksData.length <= 1) {
                    deleteBtn.classList.add('disabled');
                    deleteBtn.disabled = true;
                }
                deleteBtn.addEventListener('click', (e) => {
                    e.stopPropagation();
                    deleteTrack(track.id);
                });
                newTrackBtn.appendChild(deleteBtn);

                newTrackBtn.addEventListener('click', () => {
                    currentTrackId = track.id;
                    tracksDiv.querySelectorAll('.track-button').forEach(btn => btn.classList.remove('active'));
                    newTrackBtn.classList.add('active');
                    drawKeysAndGrid();
                });

                newTrackBtn.addEventListener('dblclick', () => {
                    const currentName = track.name;
                    const inputField = document.createElement('input');
                    inputField.type = 'text';
                    inputField.className = 'track-name-input';
                    inputField.value = currentName;

                    newTrackBtn.replaceChild(inputField, trackNameSpan);
                    inputField.focus();

                    const saveName = () => {
                        const newName = inputField.value.trim();
                        track.name = newName || `Track ${index + 1}`;
                        trackNameSpan.textContent = track.name;
                        newTrackBtn.replaceChild(trackNameSpan, inputField);
                    };

                    inputField.addEventListener('blur', saveName);
                    inputField.addEventListener('keydown', (e) => {
                        if (e.key === 'Enter') {
                            saveName();
                        }
                    });
                });

                tracksDiv.insertBefore(newTrackBtn, addTrackBtn);
            });

            const activeBtn = tracksDiv.querySelector(`.track-button[data-track-id="${currentTrackId}"]`);
            if (activeBtn) {
                activeBtn.classList.add('active');
            } else if (tracksData.length > 0) {
                currentTrackId = tracksData[0].id;
                tracksDiv.querySelector(`.track-button[data-track-id="${currentTrackId}"]`).classList.add('active');
            }
        }

        addTrackBtn.addEventListener('click', () => {
            const newTrack = { id: nextTrackId++, name: `Track ${tracksData.length + 1}`, instrument: currentInstrument };
            createTrack(newTrack);
            renderTracks();
            currentTrackId = newTrack.id;
            tracksDiv.querySelector(`.track-button[data-track-id="${currentTrackId}"]`).classList.add('active');
            drawKeysAndGrid();
        });

        // ------------------ UI and Grid Drawing Logic ------------------

        function initializeUI() {
            drawKeysAndGrid();
            updateBPM(currentBPM);
            Tone.Transport.timeSignature = [beatsPerBar, noteValue];
        }

        function updateBPM(bpm) {
            currentBPM = bpm;
            Tone.Transport.bpm.value = currentBPM;
            bpmDisplay.textContent = `BPM: ${currentBPM}`;
        }
        
        bpmSlider.addEventListener('input', () => {
            const newBPM = parseInt(bpmSlider.value, 10);
            updateBPM(newBPM);
        });

        function drawKeysAndGrid() {
            keysDiv.innerHTML = '';
            gridDiv.innerHTML = '';
            allNotes = [];
            
            const totalRows = currentOctaves * NOTES.length;
            const totalCols = 16 * beatsPerBar * (currentGridDivision / noteValue);

            const snappedColWidth = COL_WIDTH * (4 / currentGridDivision);

            for (let i = startOctave * 12 + totalRows - 1; i >= startOctave * 12; i--) {
                const octave = Math.floor(i / 12);
                const noteName = NOTES[(i % 12)];
                const fullNoteName = noteName + octave;
                allNotes.push(fullNoteName);

                let key = document.createElement("div");
                key.className = "key " + (noteName.includes("#") ? "black" : "white");
                key.textContent = noteName.startsWith("C") ? fullNoteName : noteName;
                keysDiv.appendChild(key);

                let row = document.createElement("div");
                row.className = "grid-row";
                row.dataset.note = fullNoteName;

                for (let j = 0; j < totalCols; j++) {
                    let cell = document.createElement("div");
                    cell.className = "grid-cell";
                    cell.style.width = snappedColWidth + "px";
                    
                    if (j % currentGridDivision === 0) {
                         if (j % (beatsPerBar * currentGridDivision) === 0) {
                            cell.classList.add("bar");
                        } else {
                            cell.classList.add("beat");
                        }
                    }
                    
                    cell.style.left = j * snappedColWidth + "px";
                    row.appendChild(cell);
                }
                gridDiv.appendChild(row);
            }

            gridDiv.style.width = (totalCols * snappedColWidth) + "px";
            gridDiv.style.height = (totalRows * ROW_HEIGHT) + "px";
            
            notesData.forEach(drawNote);
        }

        function drawNote(noteData) {
            let note = document.createElement("div");
            note.className = `note`;
            note.dataset.id = noteData.id;
            note.dataset.note = noteData.note;
            note.dataset.start = noteData.start;
            note.dataset.trackId = noteData.trackId;
            
            const trackIndex = tracksData.findIndex(track => track.id === noteData.trackId);
            if (trackIndex !== -1) {
                note.style.backgroundColor = TRACK_COLORS[trackIndex % TRACK_COLORS.length];
            }
            
            const snappedColWidth = COL_WIDTH * (4 / currentGridDivision);
            let rowIdx = allNotes.indexOf(noteData.note);
            
            if (rowIdx === -1) {
                console.error(`Note ${noteData.note} not found in current note range.`);
                return;
            }

            note.style.top = Math.round((rowIdx * ROW_HEIGHT) + (ROW_HEIGHT - NOTE_HEIGHT) / 2) + "px";
            note.style.left = Math.round(noteData.start * snappedColWidth) + "px";
            note.style.width = Math.round(noteData.length * snappedColWidth) + "px";

            let handle = document.createElement("div");
            handle.className = "note-handle";
            note.appendChild(handle);
            
            gridDiv.appendChild(note);
        }

        function removeNote(noteElement) {
            const noteDataToRemove = notesData.find(nd => nd.id == noteElement.dataset.id);
            if (noteDataToRemove) {
                notesData = notesData.filter(nd => nd.id !== noteDataToRemove.id);
                noteElement.remove();
                if (isAudioContextInitialized) {
                    updateAllParts();
                }
            }
        }
        
        function showNoteEditorModal(noteElement, x, y) {
            activeNoteElement = noteElement;
            const noteData = notesData.find(nd => nd.id == activeNoteElement.dataset.id);
            if (!noteData) return;

            modalStartInput.value = noteData.start;
            modalLengthInput.value = noteData.length;

            noteEditorModal.style.left = `${x}px`;
            noteEditorModal.style.top = `${y}px`;
            noteEditorModal.style.display = 'flex';
        }

        // ------------------ Event Listeners ------------------

        setTempoBtn.addEventListener('click', async () => {
            let newBeatsPerBar = prompt("新しい拍子の分子 (例: 4/4 の '4') を入力してください:", beatsPerBar);
            let newNoteValue = prompt("新しい拍子の分母 (例: 4/4 の '4') を入力してください:", noteValue);
            
            if (newBeatsPerBar !== null && newNoteValue !== null) {
                newBeatsPerBar = parseInt(newBeatsPerBar);
                newNoteValue = parseInt(newNoteValue);

                if (!isNaN(newBeatsPerBar) && !isNaN(newNoteValue) && newBeatsPerBar > 0 && newNoteValue > 0) {
                    beatsPerBar = newBeatsPerBar;
                    noteValue = newNoteValue;
                    Tone.Transport.timeSignature = [beatsPerBar, newNoteValue];
                    drawKeysAndGrid();
                    updateAllParts();
                } else {
                    alert("無効な値です。正の整数を入力してください。");
                }
            }
        });
        
        setOctaveBtn.addEventListener('click', async () => {
            let choice = prompt("オクターブ数を選択してください:\n1. 2 オクターブ (C3-C5)\n2. 5 オクターブ (C2-C7)\n3. 10 オクターブ (C0-C9)", currentOctaves == 2 ? 1 : (currentOctaves == 5 ? 2 : 3));
            if (choice !== null) {
                choice = parseInt(choice);
                if (choice === 1) {
                    currentOctaves = 2;
                    startOctave = 3;
                } else if (choice === 2) {
                    currentOctaves = 5;
                    startOctave = 2;
                } else if (choice === 3) {
                    currentOctaves = 10;
                    startOctave = 0;
                } else {
                    alert("無効な選択です。1, 2, 3のいずれかを入力してください。");
                    return;
                }
                drawKeysAndGrid();
                updateAllParts();
            }
        });

        document.addEventListener("keydown", async (e) => {
            if (e.code === 'Space') {
                e.preventDefault();
                await setupTone();
                if (!isAudioContextInitialized) return;

                if (notesData.length === 0) {
                    alert("再生するノートがありません。ノートを作成してください。");
                    return;
                }
                if (Tone.Transport.state === "stopped" || Tone.Transport.state === "paused") {
                    startPlayback();
                } else {
                    pausePlayback();
                }
            } else if (e.key === "ArrowRight") {
                e.preventDefault();
                const newPos = Tone.Transport.seconds + (60 / currentBPM) / (currentGridDivision / 4);
                Tone.Transport.seconds = newPos;
            } else if (e.key === "ArrowLeft") {
                e.preventDefault();
                const newPos = Tone.Transport.seconds - (60 / currentBPM) / (currentGridDivision / 4);
                Tone.Transport.seconds = newPos;
            }
        });
        
        gridWrapper.addEventListener('wheel', (e) => {
            e.preventDefault();
            if (e.shiftKey) {
                gridWrapper.scrollLeft += e.deltaY;
            } else {
                gridWrapper.scrollTop += e.deltaY;
            }
        }, { passive: false });

        gridWrapper.addEventListener('scroll', () => {
            keysDiv.scrollTop = gridWrapper.scrollTop;
        });
        
        let activeToneNote = null;
        
        keysDiv.addEventListener('mousedown', async (e) => {
            const keyElement = e.target.closest('.key');
            if (keyElement) {
                e.preventDefault();
                await setupTone();
                if (!isAudioContextInitialized) return;

                const keyElements = Array.from(keysDiv.children);
                const index = keyElements.indexOf(keyElement);
                if (index !== -1) {
                    const noteName = allNotes[index];
                    if (noteName) {
                        const trackInstrument = instruments[currentTrackId];
                        if (trackInstrument) {
                            trackInstrument.triggerAttack(noteName, Tone.now());
                            activeToneNote = noteName;
                        }
                    }
                }
            }
        });
        
        keysDiv.addEventListener('mouseup', () => {
            if (activeToneNote && instruments[currentTrackId]) {
                instruments[currentTrackId].triggerRelease(activeToneNote, Tone.now());
                activeToneNote = null;
            }
        });
        
        keysDiv.addEventListener('mouseleave', () => {
            if (activeToneNote && instruments[currentTrackId]) {
                instruments[currentTrackId].triggerRelease(activeToneNote, Tone.now());
                activeToneNote = null;
            }
        });

        toolButtonsDiv.querySelectorAll('button').forEach(button => {
            button.addEventListener('click', (e) => {
                const tool = e.currentTarget.dataset.tool;
                currentTool = tool;
                toolButtonsDiv.querySelectorAll('button').forEach(btn => btn.classList.remove('active'));
                e.currentTarget.classList.add('active');
                
                if (currentTool === 'pencil') {
                    gridWrapper.style.cursor = 'url("pencil.png") 16 16, auto';
                } else if (currentTool === 'eraser') {
                    gridWrapper.style.cursor = 'url("eraser.png") 16 16, auto';
                } else {
                    gridWrapper.style.cursor = 'auto';
                }
            });
        });

        document.querySelectorAll('.grid-setting').forEach(item => {
            item.addEventListener('click', (e) => {
                e.preventDefault();
                const grid = e.currentTarget.dataset.grid;
                currentGridDivision = parseInt(grid);
                document.querySelectorAll('.grid-setting').forEach(a => a.classList.remove('active'));
                e.currentTarget.classList.add('active');
                drawKeysAndGrid();
                updateAllParts();
            });
        });
        
        document.querySelectorAll('.instrument-setting').forEach(item => {
            item.addEventListener('click', async (e) => {
                e.preventDefault();
                const instrumentType = e.currentTarget.dataset.instrument;
                if (currentInstrument === instrumentType) return;
                
                currentInstrument = instrumentType;
                
                document.querySelectorAll('.instrument-setting').forEach(a => a.classList.remove('active'));
                e.currentTarget.classList.add('active');
                
                const currentTrack = tracksData.find(t => t.id === currentTrackId);
                if (currentTrack) {
                    currentTrack.instrument = currentInstrument;
                    if (isAudioContextInitialized) {
                        if (instruments[currentTrackId]) {
                            instruments[currentTrackId].dispose();
                        }
                        createInstrumentAndPart(currentTrackId, currentInstrument);
                        updateAllParts();
                    }
                }
            });
        });
        
        // ------------------ Note Creation, Move, Resize Logic ------------------
        let tempNote;
        let isErasing = false;
        
        function handleCreate(e) {
            const snappedColWidth = COL_WIDTH * 4 / currentGridDivision;
            const gridRect = gridDiv.getBoundingClientRect();
            const startX = e.clientX - gridRect.left + gridWrapper.scrollLeft;
            const startY = e.clientY - gridRect.top + gridWrapper.scrollTop;
            
            const startTick = Math.round(startX / snappedColWidth);
            const startNoteIndex = Math.floor(startY / ROW_HEIGHT);
            const noteName = allNotes[startNoteIndex];

            if (!noteName) return;
            
            const topPos = (startNoteIndex * ROW_HEIGHT) + (ROW_HEIGHT - NOTE_HEIGHT) / 2;
            tempNote = document.createElement("div");
            tempNote.className = "note";
            tempNote.style.backgroundColor = TRACK_COLORS[tracksData.findIndex(t => t.id === currentTrackId) % TRACK_COLORS.length];
            tempNote.style.top = topPos + "px";
            tempNote.style.left = startTick * snappedColWidth + "px";
            tempNote.style.width = snappedColWidth + "px";
            tempNote.dataset.note = noteName;
            tempNote.dataset.start = startTick;
            tempNote.dataset.trackId = currentTrackId;
            gridDiv.appendChild(tempNote);
            
            const handle = document.createElement("div");
            handle.className = "note-handle";
            tempNote.appendChild(handle);
            
            let isMouseMoved = false;

            const onMouseMove = (moveEvent) => {
                isMouseMoved = true;
                const currentX = moveEvent.clientX - gridRect.left + gridWrapper.scrollLeft;
                
                const endTick = Math.round(currentX / snappedColWidth);
                const newStart = Math.min(startTick, endTick);
                const newEnd = Math.max(startTick, endTick);
                const newLength = Math.max(1, newEnd - newStart);

                tempNote.style.left = `${newStart * snappedColWidth}px`;
                tempNote.style.width = `${newLength * snappedColWidth}px`;
            };

            const onMouseUp = () => {
                document.removeEventListener('mousemove', onMouseMove);
                document.removeEventListener('mouseup', onMouseUp);

                if (!tempNote) return;

                const finalStart = parseInt(tempNote.style.left) / snappedColWidth;
                const finalLength = parseInt(tempNote.style.width) / snappedColWidth;

                if (finalLength === 0) {
                     tempNote.remove();
                     tempNote = null;
                     return;
                }

                const noteData = {
                    id: nextNoteId++,
                    note: tempNote.dataset.note,
                    start: finalStart,
                    length: finalLength,
                    trackId: currentTrackId
                };
                notesData.push(noteData);
                drawNote(noteData);

                tempNote.remove();
                tempNote = null;
                
                updateAllParts();

                if (instruments[currentTrackId]) {
                    const durationInSeconds = Tone.Transport.toSeconds(`${noteData.length / currentGridDivision * 4}n`);
                    instruments[currentTrackId].triggerAttackRelease(noteData.note, durationInSeconds, Tone.now());
                }
            };
            
            document.addEventListener('mousemove', onMouseMove);
            document.addEventListener('mouseup', onMouseUp);
        }

        gridDiv.addEventListener('mousedown', async (e) => {
            await setupTone();
            if (!isAudioContextInitialized) return;
            
            const targetNote = e.target.closest('.note');
            const snappedColWidth = COL_WIDTH * 4 / currentGridDivision;

            if (e.button === 2) {
                e.preventDefault();
                if (targetNote) {
                    showNoteEditorModal(targetNote, e.clientX, e.clientY);
                }
                return;
            }

            if (currentTool === 'eraser') {
                if (targetNote) {
                    removeNote(targetNote);
                    isErasing = true;
                }
                
                document.onmousemove = (moveEvent) => {
                    if (isErasing) {
                        const hoveredNote = moveEvent.target.closest('.note');
                        if (hoveredNote) {
                            removeNote(hoveredNote);
                        }
                    }
                };
            } else if (currentTool === 'pencil') {
                if (targetNote && e.target.classList.contains("note-handle")) {
                    handleResize(e, targetNote, notesData.find(nd => nd.id == targetNote.dataset.id), snappedColWidth);
                } else if (targetNote) {
                    handleMove(e, targetNote, notesData.find(nd => nd.id == targetNote.dataset.id), snappedColWidth);
                } else {
                    handleCreate(e);
                }
            }
        });
        
        gridDiv.addEventListener('mouseup', () => {
            if (isErasing) {
                isErasing = false;
                document.onmousemove = null;
                document.onmouseup = null;
            }
        });
        
        document.addEventListener("contextmenu", e => {
            e.preventDefault();
            const noteElement = e.target.closest('.note');
            if (noteElement) {
                showNoteEditorModal(noteElement, e.clientX, e.clientY);
            }
        });

        document.addEventListener('click', (e) => {
            if (!noteEditorModal.contains(e.target) && e.target.closest('.note') === null) {
                noteEditorModal.style.display = 'none';
            }
        });
        
        modalApplyBtn.addEventListener('click', () => {
            if (!activeNoteElement) return;

            const noteData = notesData.find(nd => nd.id == activeNoteElement.dataset.id);
            if (!noteData) return;

            const newStart = parseInt(modalStartInput.value, 10);
            const newLength = parseInt(modalLengthInput.value, 10);

            if (isNaN(newStart) || newStart < 0 || isNaN(newLength) || newLength < 1) {
                alert("開始位置は0以上、長さは1以上の整数を入力してください。");
                return;
            }

            noteData.start = newStart;
            noteData.length = newLength;

            const snappedColWidth = COL_WIDTH * (4 / currentGridDivision);
            activeNoteElement.style.left = `${newStart * snappedColWidth}px`;
            activeNoteElement.style.width = `${newLength * snappedColWidth}px`;
            
            updateAllParts();
            noteEditorModal.style.display = 'none';
        });

        modalDeleteBtn.addEventListener('click', () => {
            if (!activeNoteElement) return;
            removeNote(activeNoteElement);
            noteEditorModal.style.display = 'none';
        });
        
        function handleMove(e, note, noteData, snappedColWidth) {
            e.preventDefault();
            const gridRect = gridDiv.getBoundingClientRect();
            let startX = e.clientX - gridRect.left + gridWrapper.scrollLeft;
            let startY = e.clientY - gridRect.top + gridWrapper.scrollTop;
            let lastNoteName = noteData.note;

            const onMouseMove = moveEvent => {
                let newX = moveEvent.clientX - gridRect.left + gridWrapper.scrollLeft;
                let newY = moveEvent.clientY - gridRect.top + gridWrapper.scrollTop;
                
                let diffX = newX - startX;
                let diffY = newY - startY;

                let snappedX = Math.round((noteData.start * snappedColWidth + diffX) / snappedColWidth) * snappedColWidth;
                let snappedY = Math.round((allNotes.indexOf(noteData.note) * ROW_HEIGHT + diffY) / ROW_HEIGHT) * ROW_HEIGHT;
                
                note.style.left = snappedX + "px";
                note.style.top = snappedY + "px";
                
                const newNoteIndex = Math.floor(snappedY / ROW_HEIGHT);
                const newNoteName = allNotes[newNoteIndex];
                if (newNoteName !== lastNoteName) {
                    noteData.note = newNoteName;
                    lastNoteName = newNoteName;
                }
            };

            const onMouseUp = () => {
                document.removeEventListener('mousemove', onMouseMove);
                document.removeEventListener('mouseup', onMouseUp);

                noteData.start = Math.round(note.offsetLeft / snappedColWidth);
                note.dataset.note = noteData.note;
                note.dataset.start = noteData.start;
                updateAllParts();

                if (instruments[noteData.trackId]) {
                    const durationInSeconds = Tone.Transport.toSeconds(`${noteData.length / currentGridDivision * 4}n`);
                    instruments[noteData.trackId].triggerAttackRelease(noteData.note, durationInSeconds, Tone.now());
                }
            };

            document.addEventListener('mousemove', onMouseMove);
            document.addEventListener('mouseup', onMouseUp);
        }

        function handleResize(e, note, noteData, snappedColWidth) {
            e.preventDefault();
            const gridRect = gridDiv.getBoundingClientRect();
            let startX = e.clientX - gridRect.left + gridWrapper.scrollLeft;
            let startWidth = note.offsetWidth;

            const onMouseMove = moveEvent => {
                let newX = moveEvent.clientX - gridRect.left + gridWrapper.scrollLeft;
                let diffX = newX - startX;
                let newWidth = startWidth + diffX;
                let snappedWidth = Math.max(snappedColWidth, Math.round(newWidth / snappedColWidth) * snappedColWidth);
                
                note.style.width = snappedWidth + "px";
            };
            
            const onMouseUp = () => {
                document.removeEventListener('mousemove', onMouseMove);
                document.removeEventListener('mouseup', onMouseUp);
                noteData.length = Math.round(note.offsetWidth / snappedColWidth);
                updateAllParts();

                if (instruments[noteData.trackId]) {
                    const durationInSeconds = Tone.Transport.toSeconds(`${noteData.length / currentGridDivision * 4}n`);
                    instruments[noteData.trackId].triggerAttackRelease(noteData.note, durationInSeconds, Tone.now());
                }
            };

            document.addEventListener('mousemove', onMouseMove);
            document.addEventListener('mouseup', onMouseUp);
        }
        
        playheadDiv.addEventListener('mousedown', async (e) => {
            isPlayheadDragging = true;
            document.body.style.cursor = 'grabbing';
            const initialMouseX = e.clientX;
            const initialPlayheadX = parseFloat(playheadDiv.style.transform.replace('translateX(', '').replace('px)', '')) || 0;
            
            const wasPlaying = Tone.Transport.state === "started";
            if (wasPlaying) {
                pausePlayback();
                wasPlayingBeforeDrag = true;
            }

            document.onmousemove = (moveEvent) => {
                const diffX = moveEvent.clientX - initialMouseX;
                const newX = initialPlayheadX + diffX;
                
                const gridWidth = gridDiv.offsetWidth;
                const snappedColWidth = COL_WIDTH * (4 / currentGridDivision);
                const clampedX = Math.max(0, Math.min(gridWidth, newX));
                const snappedX = Math.round(clampedX / snappedColWidth) * snappedColWidth;
                
                playheadDiv.style.transform = `translateX(${snappedX}px)`;
                Tone.Transport.seconds = (snappedX / snappedColWidth) * Tone.Transport.toSeconds(`${4 / currentGridDivision}n`);
            };

            document.onmouseup = () => {
                isPlayheadDragging = false;
                document.body.style.cursor = 'default';
                document.onmousemove = null;
                document.onmouseup = null;
                if (wasPlayingBeforeDrag) {
                    startPlayback();
                    wasPlayingBeforeDrag = false;
                }
            };
        });

        saveBtn.addEventListener('click', () => {
            const data = {
                notes: notesData,
                tracks: tracksData,
                currentOctaves: currentOctaves,
                startOctave: startOctave,
                currentBPM: currentBPM,
                beatsPerBar: beatsPerBar,
                noteValue: noteValue,
                currentGridDivision: currentGridDivision
            };
            const jsonString = JSON.stringify(data);
            const blob = new Blob([jsonString], {type: "application/json"});
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = 'project.mcp';
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            URL.revokeObjectURL(url);
        });

        loadBtn.addEventListener('click', () => {
            const input = document.createElement('input');
            input.type = 'file';
            input.accept = '.mcp';
            input.onchange = (e) => {
                const file = e.target.files[0];
                if (!file) return;

                const reader = new FileReader();
                reader.onload = (e) => {
                    try {
                        const data = JSON.parse(e.target.result);
                        notesData = data.notes;
                        tracksData = data.tracks;
                        currentOctaves = data.currentOctaves;
                        startOctave = data.startOctave;
                        currentBPM = data.currentBPM;
                        beatsPerBar = data.beatsPerBar;
                        noteValue = data.noteValue;
                        currentGridDivision = data.currentGridDivision;

                        renderTracks();
                        drawKeysAndGrid();
                        updateBPM(currentBPM);
                        Tone.Transport.timeSignature = [beatsPerBar, noteValue];
                        Tone.Transport.bpm.value = currentBPM;
                        updateAllParts();

                        alert("プロジェクトが正常に読み込まれました。");
                    } catch (error) {
                        alert("ファイルの読み込みに失敗しました。無効なファイル形式です。");
                        console.error("Load failed:", error);
                    }
                };
                reader.readAsText(file);
            };
            input.click();
        });
        
        importMidiBtn.addEventListener('click', () => {
            const input = document.createElement('input');
            input.type = 'file';
            input.accept = '.mid';
            input.onchange = async (e) => {
                const file = e.target.files[0];
                if (!file) return;
                
                const reader = new FileReader();
                reader.onload = async (e) => {
                    const arrayBuffer = e.target.result;
                    const midi = new MIDI.MIDIFile(arrayBuffer);
                    
                    const newNotes = [];
                    const newTracks = new Map();
                    let maxNoteId = notesData.length > 0 ? Math.max(...notesData.map(n => n.id)) : -1;
                    
                    midi.getEvents().forEach(event => {
                        if (event.type === 'noteOn' && event.channel < 16) {
                            const trackId = event.track;
                            const noteName = Tone.Frequency(event.noteNumber, 'midi').toNote();
                            const duration = event.duration;
                            const startTick = event.tick;
                            
                            if (!newTracks.has(trackId)) {
                                const newTrackData = {
                                    id: nextTrackId++,
                                    name: `MIDI Track ${trackId + 1}`,
                                    instrument: 'synth'
                                };
                                newTracks.set(trackId, newTrackData.id);
                                tracksData.push(newTrackData);
                                createInstrumentAndPart(newTrackData.id, newTrackData.instrument);
                            }
                            
                            newNotes.push({
                                id: ++maxNoteId,
                                note: noteName,
                                start: startTick / midi.header.ticksPerBeat * currentGridDivision,
                                length: duration / midi.header.ticksPerBeat * currentGridDivision,
                                trackId: newTracks.get(trackId)
                            });
                        }
                    });

                    notesData = notesData.concat(newNotes);
                    
                    renderTracks();
                    drawKeysAndGrid();
                    updateAllParts();

                    alert("MIDIファイルが正常に読み込まれました。");
                };
                reader.readAsArrayBuffer(file);
            };
            input.click();
        });
        
        exportMidiBtn.addEventListener('click', () => {
            const midiBuilder = new MIDI.MIDIBuilder();
            const tracks = new Map();

            notesData.forEach(note => {
                const noteName = note.note;
                const startTick = note.start / currentGridDivision * Tone.Transport.ppq;
                const durationTicks = note.length / currentGridDivision * Tone.Transport.ppq;

                if (!tracks.has(note.trackId)) {
                    tracks.set(note.trackId, midiBuilder.addTrack());
                }

                const track = tracks.get(note.trackId);
                const noteNumber = Tone.Frequency(noteName).toMidi();
                track.addNote(noteNumber, startTick, durationTicks);
            });
            
            midiBuilder.addTempo(currentBPM);
            const midiData = midiBuilder.build();
            const blob = new Blob([midiData], { type: "audio/midi" });
            
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = 'export.mid';
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            URL.revokeObjectURL(url);
        });

    </script>

</body>
</html>
